import numpy as np
import xarray as xr
import pandas as pd
import scipy.io as sio
import datetime
import os.path

# Loader functions and datatype classes will be defined in this module. 
class assemble:
    def __init__(self, obj_id, paths ):
        self.name = obj_id['name'];
        self.type = obj_id['type'];
        self.project = obj_id['project']; 
        self.limits = obj_id['limits'];
        self.paths = paths; 
        
        # Now list properties that will be generated by class methods.
        self.grids = dict(); # they will be pandas, numpy, and xarray objects.
        self.vars = dict(); 
     
    def retrieve(self,filename, fileformat):
            
        if fileformat in ['.nc','.netcdf','.nc4']:
            dataset = xr.open_dataset(filename);
        elif fileformat == '.mat':
            dataset = sio.loadmat(filename);
        return dataset
            
    def store_nc(self,filepaths,varname,limits='none'): 
		# mat support is experimental
        # This method will:
        # 1. Load dataset from "filename"
        # 2. Extract variable grid from "varname" in that dataset. 
        # 3. Store list of variable's grid inside of self.grids
        cutgrid = isinstance(limits,dict);     
        for item in varname: 
            myvar = []; # store vals here
            for kk in range(len(filepaths)): 
                filename = filepaths[kk]; 
                datform = os.path.splitext(filename); # get data format
                dataset = self.retrieve(filename,datform[1]);

                myvar.insert(kk, dataset[item]);   
            #   If cut=True, load only a slice into memory 
                if cutgrid:
                    myvar.insert(kk, myvar[kk].sel(time=slice(limits['t0'],limits['t1'])) );         

        # Store list of grids in dictionary
            self.grids[item] = myvar;


    def interp_grid(self, variables, sorter ):
        '''  This method takes dictionary list items within self.grids[variable]
        - - format of items must be xr.DataArray 
        - - all items are interpolated onto a new set of axes 
        - - sorter is the str() for whatever dim unites measurements 
                           for moorings it's usually depth or z '''
        
        source_coords = dict(); 
        source_data = dict(); 
        cake = []; 
        
        # Cyle through all variables requested
        for kk in range(len(variables)):
            datlist = self.grids[variables[kk]];
            vardata = [];
            varcoords = []; 
            # Data array with all values
            all_inst = xr.concat( datlist, dim=sorter )
            all_inst[sorter] = all_inst[sorter] + 1e-5*np.random.rand( len(all_inst[sorter]) ); 
            all_inst = all_inst.sortby(sorter); 
            
            if all_inst.dims[1] == sorter:
                all_inst = all_inst.transpose(); # only works for 2d objects

            all_inst = all_inst.interpolate_na(dim=sorter);
            self.grids[variables[kk]] = all_inst; # replace list for single xr object
     
		   
		   
#    def make_multivar(self, vars2get, filepaths):
		# Input a dictionary whose keys are variable names, and content are 
		# lists with files where each variable is stored 
	
#    def unifygrid(self, variable, common_vecs):
#        varexists = variable in self.grids; 
#        if varexists == False:
#            print('Variable files have not been loaded');
#            return 
        
    def gridtime(self, varname):
        gridobj = self.grids[varname];
        return gridobj.time

''' BELOW ARE THE FUNCTIONS THAT ALLOW .MAT SUPPORT '''
class matfile:
    def __init__(self,filepath, notes='none'):
        self.path = filepath; 
        self.notes= notes;  
        self.data = sio.loadmat(filepath); 
	
    def which_keys(self):
        print(self.data.keys())

    def read_var(self, variable):
        if isinstance(variable,str):
            var_data = self.data[variable]; 
        elif isinstance(variable,list): 
            var_data = dict(); 
            for item in variable:
                var_data[item] = self.data[item]; 
        return var_data;
        
    def read_struct(self, structname, vars2get): 
        struct_data = dict(); 
        for item in vars2get:
            struct_data[item] = self.data[structname][0][item][0];
        return struct_data
        
    def read_cell(self, cellname, indices2get):
        matcell = self.data[cellname][0,0]; # extract only usable info
        list_form = [matcell[index][0] for index in indices2get];
        return list_form;     

    def datenum_to_datetime(self, dnumvec): 
    # Take in a sequence of matlab datenum objects and transform  
    # into python datetimes 
        ref_date = datetime.datetime.strptime('Jan 01 1900 00:00','%b %d %Y %H:%M');
        ref_num = 693962; # ref_date in matlab format
        py_deltas = [datetime.timedelta(days=(dtn-ref_num)) for dtn in dnumvec]; 
        py_dates = [ref_date + dt for dt in py_deltas];
        return py_dates 
    
    def var_to_xr(self, varnames, dimnames, in_struct='none',datenumdim='none'):
        # Assynes tgat ciirdubate are stored under the names of dimnames
        if in_struct=='none':
            my_coords = self.read_var(dimnames);
            var_data = self.read_var(varnames);	
        else:
            my_coords = self.read_struct( in_struct, dimnames);
            var_data = self.read_struct( in_struct, varnames ); 
            for dim in dimnames: 
                if len(my_coords[dim].shape) == 2:
                    my_coords[dim] = np.reshape( my_coords[dim],-1); 
                if dim == datenumdim:
                    my_coords[dim] = self.datenum_to_datetime(my_coords[dim]); 
        
        xrobj = xr.DataArray(data=var_data[varnames[0]], coords=my_coords, dims=dimnames); 	
        return xrobj
        
        
        
def mat2xr(matfile,varnames,dimnames,struct_name='none',to_grid=False):
	# This assumes that coordinates are stored under the same dimname
	# inside the matfile.
	# struct_name refers to whether variables and coords are inside a mat structure

    if struct_name=='none':
        coords = readmat( matfile, dimnames); 
        data = readmat( matfile, varnames); # creates dictionary
    else:
        my_data = readmat( matfile, [], {struct_name:varnames}); 
        my_coords = readmat( matfile, [], {struct_name:dimnames}); 
        # Remove one dimension from coordinate data
        for dim in dimnames:
            if len(my_coords[dim].shape) == 2:
                my_coords[dim] = np.reshape( my_coords[dim],-1);
            if dim == 'time': # change date format 
                my_coords[dim] = datenum(my_coords[dim]);  
    xrobj = xr.DataArray(data=my_data[varnames[0]], coords=my_coords, dims=dimnames);  
    return xrobj
