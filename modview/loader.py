import numpy as np
import xarray as xr
import pandas as pd
import scipy.io as sio
import datetime

def readmat(filepath, variables, structures='none'):
    # Get data from a matfile 
    # filepath refers to .mat file
    # variables is a list
    # structures is a dictionary. Keys are names of structs, values are lists with variables inside structs
    
    matfile = sio.loadmat(filepath);
    data = dict();     
    for item in variables:
        data[item] = matfile[item]; # write data in dict
    
    for item in list(structures):
        vars2get = structures[item]; # list of variable names
        for kk in vars2get:
            data[kk] = matfile[item][0][kk][0]; # get data inside struct
    # Returns a dictionary with all requested variables 
    return data
    
def datenum(dnumvec):
    ''' 
    Take in a sequence of matlab datenum objects and transform it into 
    python datetimes '''
    ref_date = datetime.datetime.strptime('Jul 14 1916 00:00','%b %d %Y %H:%M');
    ref_num = 7e5; # ref_date in matlab format
    
    py_deltas = [datetime.timedelta(days=(dtn-ref_num)) for dtn in dnumvec]; 
    py_dates = [ref_date + dt for dt in py_deltas];
    return py_dates
	
# Loader functions and datatype classes will be defined in this module. 
class assemble:
    def __init__(self, obj_id, paths ):
        self.name = obj_id['name'];
        self.type = obj_id['type'];
        self.project = obj_id['project']; 
        self.limits = obj_id['limits'];
        self.files = paths; 
        
        # Now list properties that will be generated by class methods.
        self.grids = dict(); # they will be pandas, numpy, and xarray objects.
        self.vars = dict(); 
     
    def retrieve(self,filename, fileformat):
            
        if fileformat == 'netcdf':
            dataset = xr.open_dataset(filename);
        elif fileformat == 'mat':
            dataset = sio.loadmat(filename);
        return dataset
            
#    def cyclethru(self):
#        filelist = self.files.copy();
#        print( [self.files[kk]  for kk in range(len(filelist))] );
            
    def storevar(self,filepaths,varname,limits='none'): # ONLY WORKS FOR DATA LOADED AS XARRAY OBJECT
        # This method will:
        # 1. Load dataset from "file"
        dataset = [self.retrieve(filename,'netcdf') for filename in filepaths];
        # 2. Extract variable grid from "varname" in that dataset. 
        myvar = [dataset[kk][varname] for kk in range(len(filepaths))];   
        #        If cut=True, load only a slice into memory 
        if isinstance(limits, dict):
            if limits['t0'] != 'none':
                myvar = [myvar[kk].sel(time=slice(limits['t0'],limits['t1'])) for kk in range(len(filename))];         
        # 3. Store variable grid inside of self.grids.
        self.grids[varname] = myvar;
        #print(self.grids)
    
    def interp_grid(self, variables, sorter ):
        '''  This method takes dictionary list items within self.grids[variable]
        - - format of items must be xr.DataArray 
        - - all items are interpolated onto a new set of axes 
        - - sorter is the str() for whatever dim unites measurements 
                           for moorings it's usually depth or z '''
        
        source_coords = dict(); 
        source_data = dict(); 
        cake = []; 
        
        # Cyle through all variables requested
        for kk in range(len(variables)):
            datlist = self.grids[variables[kk]];
            vardata = [];
            varcoords = []; 
            # Data array with all values
            all_inst = xr.concat( datlist, dim=sorter )
            all_inst[sorter] = all_inst[sorter] + 1e-5*np.random.rand( len(all_inst[sorter]) ); 
            all_inst = all_inst.sortby(sorter); 
            
            if all_inst.dims[1] == sorter:
                all_inst = all_inst.transpose(); # only works for 2d objects

            all_inst = all_inst.interpolate_na(dim=sorter);
            self.grids[variables[kk]] = all_inst; # replace list for single xr object
        
		   
		   
		   
#    def make_multivar(self, vars2get, filepaths):
		# Input a dictionary whose keys are variable names, and content are 
		# lists with files where each variable is stored 
	
#    def unifygrid(self, variable, common_vecs):
#        varexists = variable in self.grids; 
#        if varexists == False:
#            print('Variable files have not been loaded');
#            return 
        
    def gridtime(self, varname):
        gridobj = self.grids[varname];
        return gridobj.time
